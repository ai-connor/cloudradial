/*
CloudRadial

The CloudRadial API is currently in development. For more information visit <a href='https://radials.io/api' target='_blank'>https://radials.io/api</a>

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ncentral

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// EndpointAPIService EndpointAPI service
type EndpointAPIService service

type ApiV2EndpointIdEndpointIdDeleteRequest struct {
	ctx        context.Context
	ApiService *EndpointAPIService
	endpointId int32
}

func (r ApiV2EndpointIdEndpointIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EndpointIdEndpointIdDeleteExecute(r)
}

/*
V2EndpointIdEndpointIdDelete Deletes an endpoint by its ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param endpointId The endpoint ID
	@return ApiV2EndpointIdEndpointIdDeleteRequest
*/
func (a *EndpointAPIService) V2EndpointIdEndpointIdDelete(ctx context.Context, endpointId int32) ApiV2EndpointIdEndpointIdDeleteRequest {
	return ApiV2EndpointIdEndpointIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		endpointId: endpointId,
	}
}

// Execute executes the request
func (a *EndpointAPIService) V2EndpointIdEndpointIdDeleteExecute(r ApiV2EndpointIdEndpointIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2EndpointIdEndpointIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/endpoint/id/{endpointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointId"+"}", url.PathEscape(parameterValueToString(r.endpointId, "endpointId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EndpointIdEndpointIdGetRequest struct {
	ctx        context.Context
	ApiService *EndpointAPIService
	endpointId int32
}

func (r ApiV2EndpointIdEndpointIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EndpointIdEndpointIdGetExecute(r)
}

/*
V2EndpointIdEndpointIdGet Gets an endpoint by its ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param endpointId The endpoint ID
	@return ApiV2EndpointIdEndpointIdGetRequest
*/
func (a *EndpointAPIService) V2EndpointIdEndpointIdGet(ctx context.Context, endpointId int32) ApiV2EndpointIdEndpointIdGetRequest {
	return ApiV2EndpointIdEndpointIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		endpointId: endpointId,
	}
}

// Execute executes the request
func (a *EndpointAPIService) V2EndpointIdEndpointIdGetExecute(r ApiV2EndpointIdEndpointIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2EndpointIdEndpointIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/endpoint/id/{endpointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointId"+"}", url.PathEscape(parameterValueToString(r.endpointId, "endpointId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EndpointIdEndpointIdPatchRequest struct {
	ctx        context.Context
	ApiService *EndpointAPIService
	endpointId int32
	operation  *[]Operation
}

// The patch document
func (r ApiV2EndpointIdEndpointIdPatchRequest) Operation(operation []Operation) ApiV2EndpointIdEndpointIdPatchRequest {
	r.operation = &operation
	return r
}

func (r ApiV2EndpointIdEndpointIdPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EndpointIdEndpointIdPatchExecute(r)
}

/*
V2EndpointIdEndpointIdPatch Patches an endpoint using the JSONPatch format.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param endpointId The endpoint ID
	@return ApiV2EndpointIdEndpointIdPatchRequest
*/
func (a *EndpointAPIService) V2EndpointIdEndpointIdPatch(ctx context.Context, endpointId int32) ApiV2EndpointIdEndpointIdPatchRequest {
	return ApiV2EndpointIdEndpointIdPatchRequest{
		ApiService: a,
		ctx:        ctx,
		endpointId: endpointId,
	}
}

// Execute executes the request
func (a *EndpointAPIService) V2EndpointIdEndpointIdPatchExecute(r ApiV2EndpointIdEndpointIdPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2EndpointIdEndpointIdPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/endpoint/id/{endpointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointId"+"}", url.PathEscape(parameterValueToString(r.endpointId, "endpointId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.operation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EndpointIdEndpointIdPutRequest struct {
	ctx        context.Context
	ApiService *EndpointAPIService
	endpointId int32
	endpoint   *Endpoint
}

// The endpoint
func (r ApiV2EndpointIdEndpointIdPutRequest) Endpoint(endpoint Endpoint) ApiV2EndpointIdEndpointIdPutRequest {
	r.endpoint = &endpoint
	return r
}

func (r ApiV2EndpointIdEndpointIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EndpointIdEndpointIdPutExecute(r)
}

/*
V2EndpointIdEndpointIdPut Replaces endpoint data with the supplied values. Not including a value will result in it being removed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param endpointId The endpoint ID
	@return ApiV2EndpointIdEndpointIdPutRequest
*/
func (a *EndpointAPIService) V2EndpointIdEndpointIdPut(ctx context.Context, endpointId int32) ApiV2EndpointIdEndpointIdPutRequest {
	return ApiV2EndpointIdEndpointIdPutRequest{
		ApiService: a,
		ctx:        ctx,
		endpointId: endpointId,
	}
}

// Execute executes the request
func (a *EndpointAPIService) V2EndpointIdEndpointIdPutExecute(r ApiV2EndpointIdEndpointIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2EndpointIdEndpointIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/endpoint/id/{endpointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointId"+"}", url.PathEscape(parameterValueToString(r.endpointId, "endpointId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpoint
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EndpointMachineNameManufacturerGetRequest struct {
	ctx          context.Context
	ApiService   *EndpointAPIService
	manufacturer string
	machineName  string
}

func (r ApiV2EndpointMachineNameManufacturerGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EndpointMachineNameManufacturerGetExecute(r)
}

/*
V2EndpointMachineNameManufacturerGet Gets an endpoint by it's machine name and manufacturer

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param manufacturer The manufacturer
	@param machineName The machine name
	@return ApiV2EndpointMachineNameManufacturerGetRequest
*/
func (a *EndpointAPIService) V2EndpointMachineNameManufacturerGet(ctx context.Context, manufacturer string, machineName string) ApiV2EndpointMachineNameManufacturerGetRequest {
	return ApiV2EndpointMachineNameManufacturerGetRequest{
		ApiService:   a,
		ctx:          ctx,
		manufacturer: manufacturer,
		machineName:  machineName,
	}
}

// Execute executes the request
func (a *EndpointAPIService) V2EndpointMachineNameManufacturerGetExecute(r ApiV2EndpointMachineNameManufacturerGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2EndpointMachineNameManufacturerGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/endpoint/{machineName}/{manufacturer}"
	localVarPath = strings.Replace(localVarPath, "{"+"manufacturer"+"}", url.PathEscape(parameterValueToString(r.manufacturer, "manufacturer")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machineName"+"}", url.PathEscape(parameterValueToString(r.machineName, "machineName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EndpointManufacturerMachineNameDeleteRequest struct {
	ctx          context.Context
	ApiService   *EndpointAPIService
	machineName  string
	manufacturer string
}

func (r ApiV2EndpointManufacturerMachineNameDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EndpointManufacturerMachineNameDeleteExecute(r)
}

/*
V2EndpointManufacturerMachineNameDelete Deletes an endpoint

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param machineName The machine name
	@param manufacturer The manufacturer
	@return ApiV2EndpointManufacturerMachineNameDeleteRequest
*/
func (a *EndpointAPIService) V2EndpointManufacturerMachineNameDelete(ctx context.Context, machineName string, manufacturer string) ApiV2EndpointManufacturerMachineNameDeleteRequest {
	return ApiV2EndpointManufacturerMachineNameDeleteRequest{
		ApiService:   a,
		ctx:          ctx,
		machineName:  machineName,
		manufacturer: manufacturer,
	}
}

// Execute executes the request
func (a *EndpointAPIService) V2EndpointManufacturerMachineNameDeleteExecute(r ApiV2EndpointManufacturerMachineNameDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2EndpointManufacturerMachineNameDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/endpoint/{manufacturer}/{machineName}"
	localVarPath = strings.Replace(localVarPath, "{"+"machineName"+"}", url.PathEscape(parameterValueToString(r.machineName, "machineName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manufacturer"+"}", url.PathEscape(parameterValueToString(r.manufacturer, "manufacturer")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EndpointManufacturerMachineNamePatchRequest struct {
	ctx          context.Context
	ApiService   *EndpointAPIService
	manufacturer string
	machineName  string
	operation    *[]Operation
}

// The patch document
func (r ApiV2EndpointManufacturerMachineNamePatchRequest) Operation(operation []Operation) ApiV2EndpointManufacturerMachineNamePatchRequest {
	r.operation = &operation
	return r
}

func (r ApiV2EndpointManufacturerMachineNamePatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EndpointManufacturerMachineNamePatchExecute(r)
}

/*
V2EndpointManufacturerMachineNamePatch Patches an endpoint using the JSONPatch format.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param manufacturer The manufacturer
	@param machineName The machine name
	@return ApiV2EndpointManufacturerMachineNamePatchRequest
*/
func (a *EndpointAPIService) V2EndpointManufacturerMachineNamePatch(ctx context.Context, manufacturer string, machineName string) ApiV2EndpointManufacturerMachineNamePatchRequest {
	return ApiV2EndpointManufacturerMachineNamePatchRequest{
		ApiService:   a,
		ctx:          ctx,
		manufacturer: manufacturer,
		machineName:  machineName,
	}
}

// Execute executes the request
func (a *EndpointAPIService) V2EndpointManufacturerMachineNamePatchExecute(r ApiV2EndpointManufacturerMachineNamePatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2EndpointManufacturerMachineNamePatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/endpoint/{manufacturer}/{machineName}"
	localVarPath = strings.Replace(localVarPath, "{"+"manufacturer"+"}", url.PathEscape(parameterValueToString(r.manufacturer, "manufacturer")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machineName"+"}", url.PathEscape(parameterValueToString(r.machineName, "machineName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.operation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EndpointManufacturerMachineNamePutRequest struct {
	ctx          context.Context
	ApiService   *EndpointAPIService
	manufacturer string
	machineName  string
	endpoint     *Endpoint
}

// The endpoint values to replace
func (r ApiV2EndpointManufacturerMachineNamePutRequest) Endpoint(endpoint Endpoint) ApiV2EndpointManufacturerMachineNamePutRequest {
	r.endpoint = &endpoint
	return r
}

func (r ApiV2EndpointManufacturerMachineNamePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EndpointManufacturerMachineNamePutExecute(r)
}

/*
V2EndpointManufacturerMachineNamePut Replaces endpoint data with the supplied values. Not including a value will result in it being removed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param manufacturer The manufacturer
	@param machineName The machine name
	@return ApiV2EndpointManufacturerMachineNamePutRequest
*/
func (a *EndpointAPIService) V2EndpointManufacturerMachineNamePut(ctx context.Context, manufacturer string, machineName string) ApiV2EndpointManufacturerMachineNamePutRequest {
	return ApiV2EndpointManufacturerMachineNamePutRequest{
		ApiService:   a,
		ctx:          ctx,
		manufacturer: manufacturer,
		machineName:  machineName,
	}
}

// Execute executes the request
func (a *EndpointAPIService) V2EndpointManufacturerMachineNamePutExecute(r ApiV2EndpointManufacturerMachineNamePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2EndpointManufacturerMachineNamePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/endpoint/{manufacturer}/{machineName}"
	localVarPath = strings.Replace(localVarPath, "{"+"manufacturer"+"}", url.PathEscape(parameterValueToString(r.manufacturer, "manufacturer")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machineName"+"}", url.PathEscape(parameterValueToString(r.machineName, "machineName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpoint
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EndpointManufacturerMachineNameUpdateWarrantyPostRequest struct {
	ctx          context.Context
	ApiService   *EndpointAPIService
	manufacturer string
	machineName  string
}

func (r ApiV2EndpointManufacturerMachineNameUpdateWarrantyPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EndpointManufacturerMachineNameUpdateWarrantyPostExecute(r)
}

/*
V2EndpointManufacturerMachineNameUpdateWarrantyPost Triggers an asyncronous warranty update for the found endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param manufacturer The manufacturer
	@param machineName The machine name
	@return ApiV2EndpointManufacturerMachineNameUpdateWarrantyPostRequest
*/
func (a *EndpointAPIService) V2EndpointManufacturerMachineNameUpdateWarrantyPost(ctx context.Context, manufacturer string, machineName string) ApiV2EndpointManufacturerMachineNameUpdateWarrantyPostRequest {
	return ApiV2EndpointManufacturerMachineNameUpdateWarrantyPostRequest{
		ApiService:   a,
		ctx:          ctx,
		manufacturer: manufacturer,
		machineName:  machineName,
	}
}

// Execute executes the request
func (a *EndpointAPIService) V2EndpointManufacturerMachineNameUpdateWarrantyPostExecute(r ApiV2EndpointManufacturerMachineNameUpdateWarrantyPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2EndpointManufacturerMachineNameUpdateWarrantyPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/endpoint/{manufacturer}/{machineName}/update-warranty"
	localVarPath = strings.Replace(localVarPath, "{"+"manufacturer"+"}", url.PathEscape(parameterValueToString(r.manufacturer, "manufacturer")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machineName"+"}", url.PathEscape(parameterValueToString(r.machineName, "machineName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EndpointPostRequest struct {
	ctx        context.Context
	ApiService *EndpointAPIService
	endpoint   *Endpoint
}

// The data to create the endpoint
func (r ApiV2EndpointPostRequest) Endpoint(endpoint Endpoint) ApiV2EndpointPostRequest {
	r.endpoint = &endpoint
	return r
}

func (r ApiV2EndpointPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EndpointPostExecute(r)
}

/*
V2EndpointPost Creates an endpoint

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV2EndpointPostRequest
*/
func (a *EndpointAPIService) V2EndpointPost(ctx context.Context) ApiV2EndpointPostRequest {
	return ApiV2EndpointPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *EndpointAPIService) V2EndpointPostExecute(r ApiV2EndpointPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2EndpointPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/endpoint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpoint
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EndpointSerialNumberDeleteRequest struct {
	ctx          context.Context
	ApiService   *EndpointAPIService
	serialNumber string
}

func (r ApiV2EndpointSerialNumberDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EndpointSerialNumberDeleteExecute(r)
}

/*
V2EndpointSerialNumberDelete Deletes an endpoint

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serialNumber The serial number
	@return ApiV2EndpointSerialNumberDeleteRequest
*/
func (a *EndpointAPIService) V2EndpointSerialNumberDelete(ctx context.Context, serialNumber string) ApiV2EndpointSerialNumberDeleteRequest {
	return ApiV2EndpointSerialNumberDeleteRequest{
		ApiService:   a,
		ctx:          ctx,
		serialNumber: serialNumber,
	}
}

// Execute executes the request
func (a *EndpointAPIService) V2EndpointSerialNumberDeleteExecute(r ApiV2EndpointSerialNumberDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2EndpointSerialNumberDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/endpoint/{serialNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"serialNumber"+"}", url.PathEscape(parameterValueToString(r.serialNumber, "serialNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EndpointSerialNumberGetRequest struct {
	ctx          context.Context
	ApiService   *EndpointAPIService
	serialNumber string
}

func (r ApiV2EndpointSerialNumberGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EndpointSerialNumberGetExecute(r)
}

/*
V2EndpointSerialNumberGet Get an endpoint by it's serial number

This endpoint returns an endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serialNumber The serial number of the endpoint
	@return ApiV2EndpointSerialNumberGetRequest
*/
func (a *EndpointAPIService) V2EndpointSerialNumberGet(ctx context.Context, serialNumber string) ApiV2EndpointSerialNumberGetRequest {
	return ApiV2EndpointSerialNumberGetRequest{
		ApiService:   a,
		ctx:          ctx,
		serialNumber: serialNumber,
	}
}

// Execute executes the request
func (a *EndpointAPIService) V2EndpointSerialNumberGetExecute(r ApiV2EndpointSerialNumberGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2EndpointSerialNumberGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/endpoint/{serialNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"serialNumber"+"}", url.PathEscape(parameterValueToString(r.serialNumber, "serialNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EndpointSerialNumberPatchRequest struct {
	ctx          context.Context
	ApiService   *EndpointAPIService
	serialNumber string
	operation    *[]Operation
}

// The patch document
func (r ApiV2EndpointSerialNumberPatchRequest) Operation(operation []Operation) ApiV2EndpointSerialNumberPatchRequest {
	r.operation = &operation
	return r
}

func (r ApiV2EndpointSerialNumberPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EndpointSerialNumberPatchExecute(r)
}

/*
V2EndpointSerialNumberPatch Patches an endpoint using the JSONPatch format.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serialNumber The serial number
	@return ApiV2EndpointSerialNumberPatchRequest
*/
func (a *EndpointAPIService) V2EndpointSerialNumberPatch(ctx context.Context, serialNumber string) ApiV2EndpointSerialNumberPatchRequest {
	return ApiV2EndpointSerialNumberPatchRequest{
		ApiService:   a,
		ctx:          ctx,
		serialNumber: serialNumber,
	}
}

// Execute executes the request
func (a *EndpointAPIService) V2EndpointSerialNumberPatchExecute(r ApiV2EndpointSerialNumberPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2EndpointSerialNumberPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/endpoint/{serialNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"serialNumber"+"}", url.PathEscape(parameterValueToString(r.serialNumber, "serialNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.operation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EndpointSerialNumberPutRequest struct {
	ctx          context.Context
	ApiService   *EndpointAPIService
	serialNumber string
	endpoint     *Endpoint
}

// The endpoint
func (r ApiV2EndpointSerialNumberPutRequest) Endpoint(endpoint Endpoint) ApiV2EndpointSerialNumberPutRequest {
	r.endpoint = &endpoint
	return r
}

func (r ApiV2EndpointSerialNumberPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EndpointSerialNumberPutExecute(r)
}

/*
V2EndpointSerialNumberPut Replaces endpoint data with the supplied values. Not including a value will result in it being removed.    ///

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serialNumber The serial number
	@return ApiV2EndpointSerialNumberPutRequest
*/
func (a *EndpointAPIService) V2EndpointSerialNumberPut(ctx context.Context, serialNumber string) ApiV2EndpointSerialNumberPutRequest {
	return ApiV2EndpointSerialNumberPutRequest{
		ApiService:   a,
		ctx:          ctx,
		serialNumber: serialNumber,
	}
}

// Execute executes the request
func (a *EndpointAPIService) V2EndpointSerialNumberPutExecute(r ApiV2EndpointSerialNumberPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2EndpointSerialNumberPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/endpoint/{serialNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"serialNumber"+"}", url.PathEscape(parameterValueToString(r.serialNumber, "serialNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpoint
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EndpointSerialNumberUpdateWarrantyPostRequest struct {
	ctx          context.Context
	ApiService   *EndpointAPIService
	serialNumber string
}

func (r ApiV2EndpointSerialNumberUpdateWarrantyPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2EndpointSerialNumberUpdateWarrantyPostExecute(r)
}

/*
V2EndpointSerialNumberUpdateWarrantyPost Triggers an asyncronous warranty update for the found endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serialNumber The endpoints serial number
	@return ApiV2EndpointSerialNumberUpdateWarrantyPostRequest
*/
func (a *EndpointAPIService) V2EndpointSerialNumberUpdateWarrantyPost(ctx context.Context, serialNumber string) ApiV2EndpointSerialNumberUpdateWarrantyPostRequest {
	return ApiV2EndpointSerialNumberUpdateWarrantyPostRequest{
		ApiService:   a,
		ctx:          ctx,
		serialNumber: serialNumber,
	}
}

// Execute executes the request
func (a *EndpointAPIService) V2EndpointSerialNumberUpdateWarrantyPostExecute(r ApiV2EndpointSerialNumberUpdateWarrantyPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2EndpointSerialNumberUpdateWarrantyPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/endpoint/{serialNumber}/update-warranty"
	localVarPath = strings.Replace(localVarPath, "{"+"serialNumber"+"}", url.PathEscape(parameterValueToString(r.serialNumber, "serialNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2OdataEndpointRequest struct {
	ctx        context.Context
	ApiService *EndpointAPIService
}

func (r ApiV2OdataEndpointRequest) Execute() ([]Endpoint, *http.Response, error) {
	return r.ApiService.V2OdataEndpointExecute(r)
}

/*
V2OdataEndpoint Gets endpoints

Supports OData filtering, sorting, and paging.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV2OdataEndpointRequest
*/
func (a *EndpointAPIService) V2OdataEndpoint(ctx context.Context) ApiV2OdataEndpointRequest {
	return ApiV2OdataEndpointRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Endpoint
func (a *EndpointAPIService) V2OdataEndpointExecute(r ApiV2OdataEndpointRequest) ([]Endpoint, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Endpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2OdataEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/odata/endpoint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/octet-stream", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2OdataEndpointCountRequest struct {
	ctx        context.Context
	ApiService *EndpointAPIService
}

func (r ApiV2OdataEndpointCountRequest) Execute() ([]Endpoint, *http.Response, error) {
	return r.ApiService.V2OdataEndpointCountExecute(r)
}

/*
V2OdataEndpointCount Gets endpoints

Supports OData filtering, sorting, and paging.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV2OdataEndpointCountRequest
*/
func (a *EndpointAPIService) V2OdataEndpointCount(ctx context.Context) ApiV2OdataEndpointCountRequest {
	return ApiV2OdataEndpointCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Endpoint
func (a *EndpointAPIService) V2OdataEndpointCountExecute(r ApiV2OdataEndpointCountRequest) ([]Endpoint, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Endpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointAPIService.V2OdataEndpointCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/odata/endpoint/$count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/octet-stream", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
