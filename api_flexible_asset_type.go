/*
CloudRadial

The CloudRadial API is currently in development. For more information visit <a href='https://radials.io/api' target='_blank'>https://radials.io/api</a>

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cloudradial

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// FlexibleAssetTypeAPIService FlexibleAssetTypeAPI service
type FlexibleAssetTypeAPIService service

type ApiCompatibilityFlexibleAssetTypesGetRequest struct {
	ctx           context.Context
	ApiService    *FlexibleAssetTypeAPIService
	filterId      *int32
	filterName    *string
	filterIcon    *string
	filterEnabled *bool
	pageNumber    *int32
	pageSize      *int32
	include       *string
	sort          *string
}

func (r ApiCompatibilityFlexibleAssetTypesGetRequest) FilterId(filterId int32) ApiCompatibilityFlexibleAssetTypesGetRequest {
	r.filterId = &filterId
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesGetRequest) FilterName(filterName string) ApiCompatibilityFlexibleAssetTypesGetRequest {
	r.filterName = &filterName
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesGetRequest) FilterIcon(filterIcon string) ApiCompatibilityFlexibleAssetTypesGetRequest {
	r.filterIcon = &filterIcon
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesGetRequest) FilterEnabled(filterEnabled bool) ApiCompatibilityFlexibleAssetTypesGetRequest {
	r.filterEnabled = &filterEnabled
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesGetRequest) PageNumber(pageNumber int32) ApiCompatibilityFlexibleAssetTypesGetRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesGetRequest) PageSize(pageSize int32) ApiCompatibilityFlexibleAssetTypesGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesGetRequest) Include(include string) ApiCompatibilityFlexibleAssetTypesGetRequest {
	r.include = &include
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesGetRequest) Sort(sort string) ApiCompatibilityFlexibleAssetTypesGetRequest {
	r.sort = &sort
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityFlexibleAssetTypesGetExecute(r)
}

/*
CompatibilityFlexibleAssetTypesGet Method for CompatibilityFlexibleAssetTypesGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCompatibilityFlexibleAssetTypesGetRequest
*/
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesGet(ctx context.Context) ApiCompatibilityFlexibleAssetTypesGetRequest {
	return ApiCompatibilityFlexibleAssetTypesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesGetExecute(r ApiCompatibilityFlexibleAssetTypesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetTypeAPIService.CompatibilityFlexibleAssetTypesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/flexible_asset_types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "form", "")
	}
	if r.filterName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[name]", r.filterName, "form", "")
	}
	if r.filterIcon != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[icon]", r.filterIcon, "form", "")
	}
	if r.filterEnabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[enabled]", r.filterEnabled, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompatibilityFlexibleAssetTypesIdDeleteRequest struct {
	ctx        context.Context
	ApiService *FlexibleAssetTypeAPIService
	id         int32
}

func (r ApiCompatibilityFlexibleAssetTypesIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityFlexibleAssetTypesIdDeleteExecute(r)
}

/*
CompatibilityFlexibleAssetTypesIdDelete Method for CompatibilityFlexibleAssetTypesIdDelete

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCompatibilityFlexibleAssetTypesIdDeleteRequest
*/
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesIdDelete(ctx context.Context, id int32) ApiCompatibilityFlexibleAssetTypesIdDeleteRequest {
	return ApiCompatibilityFlexibleAssetTypesIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesIdDeleteExecute(r ApiCompatibilityFlexibleAssetTypesIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetTypeAPIService.CompatibilityFlexibleAssetTypesIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/flexible_asset_types/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompatibilityFlexibleAssetTypesIdGetRequest struct {
	ctx        context.Context
	ApiService *FlexibleAssetTypeAPIService
	id         int32
	include    *string
}

func (r ApiCompatibilityFlexibleAssetTypesIdGetRequest) Include(include string) ApiCompatibilityFlexibleAssetTypesIdGetRequest {
	r.include = &include
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityFlexibleAssetTypesIdGetExecute(r)
}

/*
CompatibilityFlexibleAssetTypesIdGet Method for CompatibilityFlexibleAssetTypesIdGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCompatibilityFlexibleAssetTypesIdGetRequest
*/
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesIdGet(ctx context.Context, id int32) ApiCompatibilityFlexibleAssetTypesIdGetRequest {
	return ApiCompatibilityFlexibleAssetTypesIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesIdGetExecute(r ApiCompatibilityFlexibleAssetTypesIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetTypeAPIService.CompatibilityFlexibleAssetTypesIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/flexible_asset_types/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompatibilityFlexibleAssetTypesIdPatchRequest struct {
	ctx                                               context.Context
	ApiService                                        *FlexibleAssetTypeAPIService
	id                                                int32
	flexibleAssetTypeUpdateDtoFlexibleAssetRequestDto *FlexibleAssetTypeUpdateDtoFlexibleAssetRequestDto
}

func (r ApiCompatibilityFlexibleAssetTypesIdPatchRequest) FlexibleAssetTypeUpdateDtoFlexibleAssetRequestDto(flexibleAssetTypeUpdateDtoFlexibleAssetRequestDto FlexibleAssetTypeUpdateDtoFlexibleAssetRequestDto) ApiCompatibilityFlexibleAssetTypesIdPatchRequest {
	r.flexibleAssetTypeUpdateDtoFlexibleAssetRequestDto = &flexibleAssetTypeUpdateDtoFlexibleAssetRequestDto
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesIdPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityFlexibleAssetTypesIdPatchExecute(r)
}

/*
CompatibilityFlexibleAssetTypesIdPatch Method for CompatibilityFlexibleAssetTypesIdPatch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCompatibilityFlexibleAssetTypesIdPatchRequest
*/
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesIdPatch(ctx context.Context, id int32) ApiCompatibilityFlexibleAssetTypesIdPatchRequest {
	return ApiCompatibilityFlexibleAssetTypesIdPatchRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesIdPatchExecute(r ApiCompatibilityFlexibleAssetTypesIdPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetTypeAPIService.CompatibilityFlexibleAssetTypesIdPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/flexible_asset_types/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.flexibleAssetTypeUpdateDtoFlexibleAssetRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompatibilityFlexibleAssetTypesPostRequest struct {
	ctx                                               context.Context
	ApiService                                        *FlexibleAssetTypeAPIService
	flexibleAssetTypeCreateDtoFlexibleAssetRequestDto *FlexibleAssetTypeCreateDtoFlexibleAssetRequestDto
}

func (r ApiCompatibilityFlexibleAssetTypesPostRequest) FlexibleAssetTypeCreateDtoFlexibleAssetRequestDto(flexibleAssetTypeCreateDtoFlexibleAssetRequestDto FlexibleAssetTypeCreateDtoFlexibleAssetRequestDto) ApiCompatibilityFlexibleAssetTypesPostRequest {
	r.flexibleAssetTypeCreateDtoFlexibleAssetRequestDto = &flexibleAssetTypeCreateDtoFlexibleAssetRequestDto
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityFlexibleAssetTypesPostExecute(r)
}

/*
CompatibilityFlexibleAssetTypesPost Method for CompatibilityFlexibleAssetTypesPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCompatibilityFlexibleAssetTypesPostRequest
*/
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesPost(ctx context.Context) ApiCompatibilityFlexibleAssetTypesPostRequest {
	return ApiCompatibilityFlexibleAssetTypesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesPostExecute(r ApiCompatibilityFlexibleAssetTypesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetTypeAPIService.CompatibilityFlexibleAssetTypesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/flexible_asset_types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.flexibleAssetTypeCreateDtoFlexibleAssetRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsFieldIdGetRequest struct {
	ctx        context.Context
	ApiService *FlexibleAssetTypeAPIService
	typeId     int32
	fieldId    int32
}

func (r ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsFieldIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsFieldIdGetExecute(r)
}

/*
CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsFieldIdGet Method for CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsFieldIdGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param typeId
	@param fieldId
	@return ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsFieldIdGetRequest
*/
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsFieldIdGet(ctx context.Context, typeId int32, fieldId int32) ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsFieldIdGetRequest {
	return ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsFieldIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		typeId:     typeId,
		fieldId:    fieldId,
	}
}

// Execute executes the request
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsFieldIdGetExecute(r ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsFieldIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetTypeAPIService.CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsFieldIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/flexible_asset_types/{typeId}/relationships/flexible_asset_fields/{fieldId}"
	localVarPath = strings.Replace(localVarPath, "{"+"typeId"+"}", url.PathEscape(parameterValueToString(r.typeId, "typeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldId"+"}", url.PathEscape(parameterValueToString(r.fieldId, "fieldId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest struct {
	ctx        context.Context
	ApiService *FlexibleAssetTypeAPIService
	typeId     int32
	id         *int32
	pageNumber *int32
	pageSize   *int32
	include    *string
	sort       *string
}

func (r ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest) Id(id int32) ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest {
	r.id = &id
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest) PageNumber(pageNumber int32) ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest) PageSize(pageSize int32) ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest) Include(include string) ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest {
	r.include = &include
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest) Sort(sort string) ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest {
	r.sort = &sort
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetExecute(r)
}

/*
CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGet Method for CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param typeId
	@return ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest
*/
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGet(ctx context.Context, typeId int32) ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest {
	return ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest{
		ApiService: a,
		ctx:        ctx,
		typeId:     typeId,
	}
}

// Execute executes the request
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetExecute(r ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetTypeAPIService.CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/flexible_asset_types/{typeId}/relationships/flexible_asset_fields"
	localVarPath = strings.Replace(localVarPath, "{"+"typeId"+"}", url.PathEscape(parameterValueToString(r.typeId, "typeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsPostRequest struct {
	ctx                                                context.Context
	ApiService                                         *FlexibleAssetTypeAPIService
	typeId                                             int32
	flexibleAssetFieldCreateDtoFlexibleAssetRequestDto *FlexibleAssetFieldCreateDtoFlexibleAssetRequestDto
}

func (r ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsPostRequest) FlexibleAssetFieldCreateDtoFlexibleAssetRequestDto(flexibleAssetFieldCreateDtoFlexibleAssetRequestDto FlexibleAssetFieldCreateDtoFlexibleAssetRequestDto) ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsPostRequest {
	r.flexibleAssetFieldCreateDtoFlexibleAssetRequestDto = &flexibleAssetFieldCreateDtoFlexibleAssetRequestDto
	return r
}

func (r ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsPostExecute(r)
}

/*
CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsPost Method for CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param typeId
	@return ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsPostRequest
*/
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsPost(ctx context.Context, typeId int32) ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsPostRequest {
	return ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsPostRequest{
		ApiService: a,
		ctx:        ctx,
		typeId:     typeId,
	}
}

// Execute executes the request
func (a *FlexibleAssetTypeAPIService) CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsPostExecute(r ApiCompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetTypeAPIService.CompatibilityFlexibleAssetTypesTypeIdRelationshipsFlexibleAssetFieldsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/flexible_asset_types/{typeId}/relationships/flexible_asset_fields"
	localVarPath = strings.Replace(localVarPath, "{"+"typeId"+"}", url.PathEscape(parameterValueToString(r.typeId, "typeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.flexibleAssetFieldCreateDtoFlexibleAssetRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2FlexibleAssetTypeIdDeleteRequest struct {
	ctx        context.Context
	ApiService *FlexibleAssetTypeAPIService
	id         int32
}

func (r ApiV2FlexibleAssetTypeIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2FlexibleAssetTypeIdDeleteExecute(r)
}

/*
V2FlexibleAssetTypeIdDelete Delete a flexible asset type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The flexible asset type ID
	@return ApiV2FlexibleAssetTypeIdDeleteRequest
*/
func (a *FlexibleAssetTypeAPIService) V2FlexibleAssetTypeIdDelete(ctx context.Context, id int32) ApiV2FlexibleAssetTypeIdDeleteRequest {
	return ApiV2FlexibleAssetTypeIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *FlexibleAssetTypeAPIService) V2FlexibleAssetTypeIdDeleteExecute(r ApiV2FlexibleAssetTypeIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetTypeAPIService.V2FlexibleAssetTypeIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/flexible-asset-type/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2FlexibleAssetTypeIdGetRequest struct {
	ctx           context.Context
	ApiService    *FlexibleAssetTypeAPIService
	id            int32
	includeFields *bool
}

// Whether to include field definitions
func (r ApiV2FlexibleAssetTypeIdGetRequest) IncludeFields(includeFields bool) ApiV2FlexibleAssetTypeIdGetRequest {
	r.includeFields = &includeFields
	return r
}

func (r ApiV2FlexibleAssetTypeIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2FlexibleAssetTypeIdGetExecute(r)
}

/*
V2FlexibleAssetTypeIdGet Get a flexible asset type by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Flexible asset type ID
	@return ApiV2FlexibleAssetTypeIdGetRequest
*/
func (a *FlexibleAssetTypeAPIService) V2FlexibleAssetTypeIdGet(ctx context.Context, id int32) ApiV2FlexibleAssetTypeIdGetRequest {
	return ApiV2FlexibleAssetTypeIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *FlexibleAssetTypeAPIService) V2FlexibleAssetTypeIdGetExecute(r ApiV2FlexibleAssetTypeIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetTypeAPIService.V2FlexibleAssetTypeIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/flexible-asset-type/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFields", r.includeFields, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFields", defaultValue, "form", "")
		r.includeFields = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2FlexibleAssetTypeIdPatchRequest struct {
	ctx        context.Context
	ApiService *FlexibleAssetTypeAPIService
	id         int32
	operation  *[]Operation
}

// The JSON patch operations to apply
func (r ApiV2FlexibleAssetTypeIdPatchRequest) Operation(operation []Operation) ApiV2FlexibleAssetTypeIdPatchRequest {
	r.operation = &operation
	return r
}

func (r ApiV2FlexibleAssetTypeIdPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2FlexibleAssetTypeIdPatchExecute(r)
}

/*
V2FlexibleAssetTypeIdPatch Apply partial updates to an existing flexible asset type using JSON Patch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The flexible asset type ID
	@return ApiV2FlexibleAssetTypeIdPatchRequest
*/
func (a *FlexibleAssetTypeAPIService) V2FlexibleAssetTypeIdPatch(ctx context.Context, id int32) ApiV2FlexibleAssetTypeIdPatchRequest {
	return ApiV2FlexibleAssetTypeIdPatchRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *FlexibleAssetTypeAPIService) V2FlexibleAssetTypeIdPatchExecute(r ApiV2FlexibleAssetTypeIdPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetTypeAPIService.V2FlexibleAssetTypeIdPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/flexible-asset-type/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.operation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2FlexibleAssetTypePostRequest struct {
	ctx                            context.Context
	ApiService                     *FlexibleAssetTypeAPIService
	createFlexibleAssetTypeRequest *CreateFlexibleAssetTypeRequest
}

// The flexible asset type details with optional fields
func (r ApiV2FlexibleAssetTypePostRequest) CreateFlexibleAssetTypeRequest(createFlexibleAssetTypeRequest CreateFlexibleAssetTypeRequest) ApiV2FlexibleAssetTypePostRequest {
	r.createFlexibleAssetTypeRequest = &createFlexibleAssetTypeRequest
	return r
}

func (r ApiV2FlexibleAssetTypePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2FlexibleAssetTypePostExecute(r)
}

/*
V2FlexibleAssetTypePost Create a new flexible asset type with optional fields

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV2FlexibleAssetTypePostRequest
*/
func (a *FlexibleAssetTypeAPIService) V2FlexibleAssetTypePost(ctx context.Context) ApiV2FlexibleAssetTypePostRequest {
	return ApiV2FlexibleAssetTypePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FlexibleAssetTypeAPIService) V2FlexibleAssetTypePostExecute(r ApiV2FlexibleAssetTypePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetTypeAPIService.V2FlexibleAssetTypePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/flexible-asset-type"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFlexibleAssetTypeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2OdataFlexibleAssetTypeRequest struct {
	ctx        context.Context
	ApiService *FlexibleAssetTypeAPIService
}

func (r ApiV2OdataFlexibleAssetTypeRequest) Execute() ([]FlexibleAssetType, *http.Response, error) {
	return r.ApiService.V2OdataFlexibleAssetTypeExecute(r)
}

/*
V2OdataFlexibleAssetType Gets flexible asset types

Supports OData filtering, sorting, and paging.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV2OdataFlexibleAssetTypeRequest
*/
func (a *FlexibleAssetTypeAPIService) V2OdataFlexibleAssetType(ctx context.Context) ApiV2OdataFlexibleAssetTypeRequest {
	return ApiV2OdataFlexibleAssetTypeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []FlexibleAssetType
func (a *FlexibleAssetTypeAPIService) V2OdataFlexibleAssetTypeExecute(r ApiV2OdataFlexibleAssetTypeRequest) ([]FlexibleAssetType, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FlexibleAssetType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetTypeAPIService.V2OdataFlexibleAssetType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/odata/flexibleassettype"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/octet-stream", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2OdataFlexibleAssetTypeCountRequest struct {
	ctx        context.Context
	ApiService *FlexibleAssetTypeAPIService
}

func (r ApiV2OdataFlexibleAssetTypeCountRequest) Execute() ([]FlexibleAssetType, *http.Response, error) {
	return r.ApiService.V2OdataFlexibleAssetTypeCountExecute(r)
}

/*
V2OdataFlexibleAssetTypeCount Gets flexible asset types

Supports OData filtering, sorting, and paging.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV2OdataFlexibleAssetTypeCountRequest
*/
func (a *FlexibleAssetTypeAPIService) V2OdataFlexibleAssetTypeCount(ctx context.Context) ApiV2OdataFlexibleAssetTypeCountRequest {
	return ApiV2OdataFlexibleAssetTypeCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []FlexibleAssetType
func (a *FlexibleAssetTypeAPIService) V2OdataFlexibleAssetTypeCountExecute(r ApiV2OdataFlexibleAssetTypeCountRequest) ([]FlexibleAssetType, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FlexibleAssetType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetTypeAPIService.V2OdataFlexibleAssetTypeCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/odata/flexibleassettype/$count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/octet-stream", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
