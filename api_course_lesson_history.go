/*
CloudRadial

The CloudRadial API is currently in development. For more information visit <a href='https://radials.io/api' target='_blank'>https://radials.io/api</a>

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cloudradial

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// CourseLessonHistoryAPIService CourseLessonHistoryAPI service
type CourseLessonHistoryAPIService service

type ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdDeleteRequest struct {
	ctx               context.Context
	ApiService        *CourseLessonHistoryAPIService
	courseId          int32
	applicationUserId string
	courseLessonId    int32
	companyId         *int32
}

// Company ID for tenant isolation
func (r ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdDeleteRequest) CompanyId(companyId int32) ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdDeleteRequest {
	r.companyId = &companyId
	return r
}

func (r ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdDeleteExecute(r)
}

/*
V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdDelete Delete a course lesson history record (soft delete)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param courseId Course ID
	@param applicationUserId Application User ID
	@param courseLessonId Course lesson ID
	@return ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdDeleteRequest
*/
func (a *CourseLessonHistoryAPIService) V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdDelete(ctx context.Context, courseId int32, applicationUserId string, courseLessonId int32) ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdDeleteRequest {
	return ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdDeleteRequest{
		ApiService:        a,
		ctx:               ctx,
		courseId:          courseId,
		applicationUserId: applicationUserId,
		courseLessonId:    courseLessonId,
	}
}

// Execute executes the request
func (a *CourseLessonHistoryAPIService) V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdDeleteExecute(r ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseLessonHistoryAPIService.V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/courselessonhistory/{courseId}/{applicationUserId}/{courseLessonId}"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"applicationUserId"+"}", url.PathEscape(parameterValueToString(r.applicationUserId, "applicationUserId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"courseLessonId"+"}", url.PathEscape(parameterValueToString(r.courseLessonId, "courseLessonId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.companyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdGetRequest struct {
	ctx               context.Context
	ApiService        *CourseLessonHistoryAPIService
	courseId          int32
	applicationUserId string
	courseLessonId    int32
}

func (r ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdGetRequest) Execute() (*CourseLessonHistoryResponse, *http.Response, error) {
	return r.ApiService.V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdGetExecute(r)
}

/*
V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdGet Get a course lesson history record by composite key

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param courseId Course ID
	@param applicationUserId Application User ID
	@param courseLessonId Course lesson ID
	@return ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdGetRequest
*/
func (a *CourseLessonHistoryAPIService) V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdGet(ctx context.Context, courseId int32, applicationUserId string, courseLessonId int32) ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdGetRequest {
	return ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdGetRequest{
		ApiService:        a,
		ctx:               ctx,
		courseId:          courseId,
		applicationUserId: applicationUserId,
		courseLessonId:    courseLessonId,
	}
}

// Execute executes the request
//
//	@return CourseLessonHistoryResponse
func (a *CourseLessonHistoryAPIService) V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdGetExecute(r ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdGetRequest) (*CourseLessonHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CourseLessonHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseLessonHistoryAPIService.V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/courselessonhistory/{courseId}/{applicationUserId}/{courseLessonId}"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"applicationUserId"+"}", url.PathEscape(parameterValueToString(r.applicationUserId, "applicationUserId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"courseLessonId"+"}", url.PathEscape(parameterValueToString(r.courseLessonId, "courseLessonId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/octet-stream", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPatchRequest struct {
	ctx               context.Context
	ApiService        *CourseLessonHistoryAPIService
	courseId          int32
	applicationUserId string
	courseLessonId    int32
	companyId         *int32
	operation         *[]Operation
}

// Company ID for tenant isolation
func (r ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPatchRequest) CompanyId(companyId int32) ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPatchRequest {
	r.companyId = &companyId
	return r
}

// JSON Patch document
func (r ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPatchRequest) Operation(operation []Operation) ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPatchRequest {
	r.operation = &operation
	return r
}

func (r ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPatchExecute(r)
}

/*
V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPatch Partially update a course lesson history record using JSON Patch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param courseId Course ID
	@param applicationUserId Application User ID
	@param courseLessonId Course lesson ID
	@return ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPatchRequest
*/
func (a *CourseLessonHistoryAPIService) V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPatch(ctx context.Context, courseId int32, applicationUserId string, courseLessonId int32) ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPatchRequest {
	return ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPatchRequest{
		ApiService:        a,
		ctx:               ctx,
		courseId:          courseId,
		applicationUserId: applicationUserId,
		courseLessonId:    courseLessonId,
	}
}

// Execute executes the request
func (a *CourseLessonHistoryAPIService) V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPatchExecute(r ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseLessonHistoryAPIService.V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/courselessonhistory/{courseId}/{applicationUserId}/{courseLessonId}"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"applicationUserId"+"}", url.PathEscape(parameterValueToString(r.applicationUserId, "applicationUserId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"courseLessonId"+"}", url.PathEscape(parameterValueToString(r.courseLessonId, "courseLessonId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.companyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.operation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPutRequest struct {
	ctx                        context.Context
	ApiService                 *CourseLessonHistoryAPIService
	courseId                   int32
	applicationUserId          string
	courseLessonId             int32
	courseLessonHistoryRequest *CourseLessonHistoryRequest
}

// Updated course lesson history details
func (r ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPutRequest) CourseLessonHistoryRequest(courseLessonHistoryRequest CourseLessonHistoryRequest) ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPutRequest {
	r.courseLessonHistoryRequest = &courseLessonHistoryRequest
	return r
}

func (r ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPutExecute(r)
}

/*
V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPut Update a course lesson history record

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param courseId Course ID
	@param applicationUserId Application User ID
	@param courseLessonId Course lesson ID
	@return ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPutRequest
*/
func (a *CourseLessonHistoryAPIService) V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPut(ctx context.Context, courseId int32, applicationUserId string, courseLessonId int32) ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPutRequest {
	return ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPutRequest{
		ApiService:        a,
		ctx:               ctx,
		courseId:          courseId,
		applicationUserId: applicationUserId,
		courseLessonId:    courseLessonId,
	}
}

// Execute executes the request
func (a *CourseLessonHistoryAPIService) V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPutExecute(r ApiV2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseLessonHistoryAPIService.V2CourselessonhistoryCourseIdApplicationUserIdCourseLessonIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/courselessonhistory/{courseId}/{applicationUserId}/{courseLessonId}"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"applicationUserId"+"}", url.PathEscape(parameterValueToString(r.applicationUserId, "applicationUserId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"courseLessonId"+"}", url.PathEscape(parameterValueToString(r.courseLessonId, "courseLessonId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.courseLessonHistoryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2CourselessonhistoryPostRequest struct {
	ctx                        context.Context
	ApiService                 *CourseLessonHistoryAPIService
	courseLessonHistoryRequest *CourseLessonHistoryRequest
}

// Course lesson history details
func (r ApiV2CourselessonhistoryPostRequest) CourseLessonHistoryRequest(courseLessonHistoryRequest CourseLessonHistoryRequest) ApiV2CourselessonhistoryPostRequest {
	r.courseLessonHistoryRequest = &courseLessonHistoryRequest
	return r
}

func (r ApiV2CourselessonhistoryPostRequest) Execute() (*CourseLessonHistoryResponse, *http.Response, error) {
	return r.ApiService.V2CourselessonhistoryPostExecute(r)
}

/*
V2CourselessonhistoryPost Create a new course lesson history record

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV2CourselessonhistoryPostRequest
*/
func (a *CourseLessonHistoryAPIService) V2CourselessonhistoryPost(ctx context.Context) ApiV2CourselessonhistoryPostRequest {
	return ApiV2CourselessonhistoryPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CourseLessonHistoryResponse
func (a *CourseLessonHistoryAPIService) V2CourselessonhistoryPostExecute(r ApiV2CourselessonhistoryPostRequest) (*CourseLessonHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CourseLessonHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseLessonHistoryAPIService.V2CourselessonhistoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/courselessonhistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/octet-stream", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.courseLessonHistoryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2OdataCourseLessonHistoryRequest struct {
	ctx        context.Context
	ApiService *CourseLessonHistoryAPIService
}

func (r ApiV2OdataCourseLessonHistoryRequest) Execute() ([]CourseLessonHistory, *http.Response, error) {
	return r.ApiService.V2OdataCourseLessonHistoryExecute(r)
}

/*
V2OdataCourseLessonHistory Gets course lesson history records

Supports OData filtering, sorting, and paging.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV2OdataCourseLessonHistoryRequest
*/
func (a *CourseLessonHistoryAPIService) V2OdataCourseLessonHistory(ctx context.Context) ApiV2OdataCourseLessonHistoryRequest {
	return ApiV2OdataCourseLessonHistoryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []CourseLessonHistory
func (a *CourseLessonHistoryAPIService) V2OdataCourseLessonHistoryExecute(r ApiV2OdataCourseLessonHistoryRequest) ([]CourseLessonHistory, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CourseLessonHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseLessonHistoryAPIService.V2OdataCourseLessonHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/odata/courselessonhistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/octet-stream", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2OdataCourseLessonHistoryCountRequest struct {
	ctx        context.Context
	ApiService *CourseLessonHistoryAPIService
}

func (r ApiV2OdataCourseLessonHistoryCountRequest) Execute() ([]CourseLessonHistory, *http.Response, error) {
	return r.ApiService.V2OdataCourseLessonHistoryCountExecute(r)
}

/*
V2OdataCourseLessonHistoryCount Gets course lesson history records

Supports OData filtering, sorting, and paging.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV2OdataCourseLessonHistoryCountRequest
*/
func (a *CourseLessonHistoryAPIService) V2OdataCourseLessonHistoryCount(ctx context.Context) ApiV2OdataCourseLessonHistoryCountRequest {
	return ApiV2OdataCourseLessonHistoryCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []CourseLessonHistory
func (a *CourseLessonHistoryAPIService) V2OdataCourseLessonHistoryCountExecute(r ApiV2OdataCourseLessonHistoryCountRequest) ([]CourseLessonHistory, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CourseLessonHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseLessonHistoryAPIService.V2OdataCourseLessonHistoryCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/odata/courselessonhistory/$count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/octet-stream", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
