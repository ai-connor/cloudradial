/*
CloudRadial

The CloudRadial API is currently in development. For more information visit <a href='https://radials.io/api' target='_blank'>https://radials.io/api</a>

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ncentral

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// FlexibleAssetAPIService FlexibleAssetAPI service
type FlexibleAssetAPIService service

type ApiCompatibilityFlexibleAssetsDeleteRequest struct {
	ctx                               context.Context
	ApiService                        *FlexibleAssetAPIService
	flexibleAssetBulkDeleteRequestDto *FlexibleAssetBulkDeleteRequestDto
}

// Array of flexible asset delete DTOs
func (r ApiCompatibilityFlexibleAssetsDeleteRequest) FlexibleAssetBulkDeleteRequestDto(flexibleAssetBulkDeleteRequestDto FlexibleAssetBulkDeleteRequestDto) ApiCompatibilityFlexibleAssetsDeleteRequest {
	r.flexibleAssetBulkDeleteRequestDto = &flexibleAssetBulkDeleteRequestDto
	return r
}

func (r ApiCompatibilityFlexibleAssetsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityFlexibleAssetsDeleteExecute(r)
}

/*
CompatibilityFlexibleAssetsDelete Bulk delete flexible assets following IT Glue API specification.  Accepts an array of flexible asset delete objects with IDs inside attributes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCompatibilityFlexibleAssetsDeleteRequest
*/
func (a *FlexibleAssetAPIService) CompatibilityFlexibleAssetsDelete(ctx context.Context) ApiCompatibilityFlexibleAssetsDeleteRequest {
	return ApiCompatibilityFlexibleAssetsDeleteRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FlexibleAssetAPIService) CompatibilityFlexibleAssetsDeleteExecute(r ApiCompatibilityFlexibleAssetsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetAPIService.CompatibilityFlexibleAssetsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/flexible_assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.flexibleAssetBulkDeleteRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompatibilityFlexibleAssetsGetRequest struct {
	ctx                       context.Context
	ApiService                *FlexibleAssetAPIService
	filterFlexibleAssetTypeId *int32
	filterOrganizationId      *int32
	filterName                *string
	pageNumber                *int32
	pageSize                  *int32
	include                   *string
	sort                      *string
}

func (r ApiCompatibilityFlexibleAssetsGetRequest) FilterFlexibleAssetTypeId(filterFlexibleAssetTypeId int32) ApiCompatibilityFlexibleAssetsGetRequest {
	r.filterFlexibleAssetTypeId = &filterFlexibleAssetTypeId
	return r
}

func (r ApiCompatibilityFlexibleAssetsGetRequest) FilterOrganizationId(filterOrganizationId int32) ApiCompatibilityFlexibleAssetsGetRequest {
	r.filterOrganizationId = &filterOrganizationId
	return r
}

func (r ApiCompatibilityFlexibleAssetsGetRequest) FilterName(filterName string) ApiCompatibilityFlexibleAssetsGetRequest {
	r.filterName = &filterName
	return r
}

func (r ApiCompatibilityFlexibleAssetsGetRequest) PageNumber(pageNumber int32) ApiCompatibilityFlexibleAssetsGetRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiCompatibilityFlexibleAssetsGetRequest) PageSize(pageSize int32) ApiCompatibilityFlexibleAssetsGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiCompatibilityFlexibleAssetsGetRequest) Include(include string) ApiCompatibilityFlexibleAssetsGetRequest {
	r.include = &include
	return r
}

func (r ApiCompatibilityFlexibleAssetsGetRequest) Sort(sort string) ApiCompatibilityFlexibleAssetsGetRequest {
	r.sort = &sort
	return r
}

func (r ApiCompatibilityFlexibleAssetsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityFlexibleAssetsGetExecute(r)
}

/*
CompatibilityFlexibleAssetsGet Method for CompatibilityFlexibleAssetsGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCompatibilityFlexibleAssetsGetRequest
*/
func (a *FlexibleAssetAPIService) CompatibilityFlexibleAssetsGet(ctx context.Context) ApiCompatibilityFlexibleAssetsGetRequest {
	return ApiCompatibilityFlexibleAssetsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FlexibleAssetAPIService) CompatibilityFlexibleAssetsGetExecute(r ApiCompatibilityFlexibleAssetsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetAPIService.CompatibilityFlexibleAssetsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/flexible_assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filterFlexibleAssetTypeId == nil {
		return nil, reportError("filterFlexibleAssetTypeId is required and must be specified")
	}

	if r.filterOrganizationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[organization-id]", r.filterOrganizationId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "filter[flexible-asset-type-id]", r.filterFlexibleAssetTypeId, "form", "")
	if r.filterName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[name]", r.filterName, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[number]", r.pageNumber, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page[size]", r.pageSize, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompatibilityFlexibleAssetsIdDeleteRequest struct {
	ctx        context.Context
	ApiService *FlexibleAssetAPIService
	id         int32
}

func (r ApiCompatibilityFlexibleAssetsIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityFlexibleAssetsIdDeleteExecute(r)
}

/*
CompatibilityFlexibleAssetsIdDelete Method for CompatibilityFlexibleAssetsIdDelete

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCompatibilityFlexibleAssetsIdDeleteRequest
*/
func (a *FlexibleAssetAPIService) CompatibilityFlexibleAssetsIdDelete(ctx context.Context, id int32) ApiCompatibilityFlexibleAssetsIdDeleteRequest {
	return ApiCompatibilityFlexibleAssetsIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *FlexibleAssetAPIService) CompatibilityFlexibleAssetsIdDeleteExecute(r ApiCompatibilityFlexibleAssetsIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetAPIService.CompatibilityFlexibleAssetsIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/flexible_assets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompatibilityFlexibleAssetsIdGetRequest struct {
	ctx        context.Context
	ApiService *FlexibleAssetAPIService
	id         int32
	include    *string
}

func (r ApiCompatibilityFlexibleAssetsIdGetRequest) Include(include string) ApiCompatibilityFlexibleAssetsIdGetRequest {
	r.include = &include
	return r
}

func (r ApiCompatibilityFlexibleAssetsIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityFlexibleAssetsIdGetExecute(r)
}

/*
CompatibilityFlexibleAssetsIdGet Method for CompatibilityFlexibleAssetsIdGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCompatibilityFlexibleAssetsIdGetRequest
*/
func (a *FlexibleAssetAPIService) CompatibilityFlexibleAssetsIdGet(ctx context.Context, id int32) ApiCompatibilityFlexibleAssetsIdGetRequest {
	return ApiCompatibilityFlexibleAssetsIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *FlexibleAssetAPIService) CompatibilityFlexibleAssetsIdGetExecute(r ApiCompatibilityFlexibleAssetsIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetAPIService.CompatibilityFlexibleAssetsIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/flexible_assets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompatibilityFlexibleAssetsIdPatchRequest struct {
	ctx                                           context.Context
	ApiService                                    *FlexibleAssetAPIService
	id                                            int32
	flexibleAssetUpdateDtoFlexibleAssetRequestDto *FlexibleAssetUpdateDtoFlexibleAssetRequestDto
}

func (r ApiCompatibilityFlexibleAssetsIdPatchRequest) FlexibleAssetUpdateDtoFlexibleAssetRequestDto(flexibleAssetUpdateDtoFlexibleAssetRequestDto FlexibleAssetUpdateDtoFlexibleAssetRequestDto) ApiCompatibilityFlexibleAssetsIdPatchRequest {
	r.flexibleAssetUpdateDtoFlexibleAssetRequestDto = &flexibleAssetUpdateDtoFlexibleAssetRequestDto
	return r
}

func (r ApiCompatibilityFlexibleAssetsIdPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityFlexibleAssetsIdPatchExecute(r)
}

/*
CompatibilityFlexibleAssetsIdPatch Method for CompatibilityFlexibleAssetsIdPatch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCompatibilityFlexibleAssetsIdPatchRequest
*/
func (a *FlexibleAssetAPIService) CompatibilityFlexibleAssetsIdPatch(ctx context.Context, id int32) ApiCompatibilityFlexibleAssetsIdPatchRequest {
	return ApiCompatibilityFlexibleAssetsIdPatchRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *FlexibleAssetAPIService) CompatibilityFlexibleAssetsIdPatchExecute(r ApiCompatibilityFlexibleAssetsIdPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetAPIService.CompatibilityFlexibleAssetsIdPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/flexible_assets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.flexibleAssetUpdateDtoFlexibleAssetRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompatibilityFlexibleAssetsPatchRequest struct {
	ctx                                                   context.Context
	ApiService                                            *FlexibleAssetAPIService
	flexibleAssetBulkUpdateDtoListFlexibleAssetRequestDto *FlexibleAssetBulkUpdateDtoListFlexibleAssetRequestDto
}

func (r ApiCompatibilityFlexibleAssetsPatchRequest) FlexibleAssetBulkUpdateDtoListFlexibleAssetRequestDto(flexibleAssetBulkUpdateDtoListFlexibleAssetRequestDto FlexibleAssetBulkUpdateDtoListFlexibleAssetRequestDto) ApiCompatibilityFlexibleAssetsPatchRequest {
	r.flexibleAssetBulkUpdateDtoListFlexibleAssetRequestDto = &flexibleAssetBulkUpdateDtoListFlexibleAssetRequestDto
	return r
}

func (r ApiCompatibilityFlexibleAssetsPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityFlexibleAssetsPatchExecute(r)
}

/*
CompatibilityFlexibleAssetsPatch Method for CompatibilityFlexibleAssetsPatch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCompatibilityFlexibleAssetsPatchRequest
*/
func (a *FlexibleAssetAPIService) CompatibilityFlexibleAssetsPatch(ctx context.Context) ApiCompatibilityFlexibleAssetsPatchRequest {
	return ApiCompatibilityFlexibleAssetsPatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FlexibleAssetAPIService) CompatibilityFlexibleAssetsPatchExecute(r ApiCompatibilityFlexibleAssetsPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetAPIService.CompatibilityFlexibleAssetsPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/flexible_assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.flexibleAssetBulkUpdateDtoListFlexibleAssetRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompatibilityFlexibleAssetsPostRequest struct {
	ctx                                           context.Context
	ApiService                                    *FlexibleAssetAPIService
	flexibleAssetCreateDtoFlexibleAssetRequestDto *FlexibleAssetCreateDtoFlexibleAssetRequestDto
}

func (r ApiCompatibilityFlexibleAssetsPostRequest) FlexibleAssetCreateDtoFlexibleAssetRequestDto(flexibleAssetCreateDtoFlexibleAssetRequestDto FlexibleAssetCreateDtoFlexibleAssetRequestDto) ApiCompatibilityFlexibleAssetsPostRequest {
	r.flexibleAssetCreateDtoFlexibleAssetRequestDto = &flexibleAssetCreateDtoFlexibleAssetRequestDto
	return r
}

func (r ApiCompatibilityFlexibleAssetsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityFlexibleAssetsPostExecute(r)
}

/*
CompatibilityFlexibleAssetsPost Method for CompatibilityFlexibleAssetsPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCompatibilityFlexibleAssetsPostRequest
*/
func (a *FlexibleAssetAPIService) CompatibilityFlexibleAssetsPost(ctx context.Context) ApiCompatibilityFlexibleAssetsPostRequest {
	return ApiCompatibilityFlexibleAssetsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FlexibleAssetAPIService) CompatibilityFlexibleAssetsPostExecute(r ApiCompatibilityFlexibleAssetsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetAPIService.CompatibilityFlexibleAssetsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/flexible_assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.flexibleAssetCreateDtoFlexibleAssetRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompatibilityOrganizationsOrgIdRelationshipsFlexibleAssetsPostRequest struct {
	ctx                                               context.Context
	ApiService                                        *FlexibleAssetAPIService
	orgId                                             int32
	flexibleAssetCreateDtoListFlexibleAssetRequestDto *FlexibleAssetCreateDtoListFlexibleAssetRequestDto
}

func (r ApiCompatibilityOrganizationsOrgIdRelationshipsFlexibleAssetsPostRequest) FlexibleAssetCreateDtoListFlexibleAssetRequestDto(flexibleAssetCreateDtoListFlexibleAssetRequestDto FlexibleAssetCreateDtoListFlexibleAssetRequestDto) ApiCompatibilityOrganizationsOrgIdRelationshipsFlexibleAssetsPostRequest {
	r.flexibleAssetCreateDtoListFlexibleAssetRequestDto = &flexibleAssetCreateDtoListFlexibleAssetRequestDto
	return r
}

func (r ApiCompatibilityOrganizationsOrgIdRelationshipsFlexibleAssetsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompatibilityOrganizationsOrgIdRelationshipsFlexibleAssetsPostExecute(r)
}

/*
CompatibilityOrganizationsOrgIdRelationshipsFlexibleAssetsPost Method for CompatibilityOrganizationsOrgIdRelationshipsFlexibleAssetsPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiCompatibilityOrganizationsOrgIdRelationshipsFlexibleAssetsPostRequest
*/
func (a *FlexibleAssetAPIService) CompatibilityOrganizationsOrgIdRelationshipsFlexibleAssetsPost(ctx context.Context, orgId int32) ApiCompatibilityOrganizationsOrgIdRelationshipsFlexibleAssetsPostRequest {
	return ApiCompatibilityOrganizationsOrgIdRelationshipsFlexibleAssetsPostRequest{
		ApiService: a,
		ctx:        ctx,
		orgId:      orgId,
	}
}

// Execute executes the request
func (a *FlexibleAssetAPIService) CompatibilityOrganizationsOrgIdRelationshipsFlexibleAssetsPostExecute(r ApiCompatibilityOrganizationsOrgIdRelationshipsFlexibleAssetsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetAPIService.CompatibilityOrganizationsOrgIdRelationshipsFlexibleAssetsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compatibility/organizations/{orgId}/relationships/flexible_assets"
	localVarPath = strings.Replace(localVarPath, "{"+"orgId"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.flexibleAssetCreateDtoListFlexibleAssetRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2FlexibleAssetIdDeleteRequest struct {
	ctx        context.Context
	ApiService *FlexibleAssetAPIService
	id         int32
}

func (r ApiV2FlexibleAssetIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2FlexibleAssetIdDeleteExecute(r)
}

/*
V2FlexibleAssetIdDelete Delete a flexible asset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The flexible asset ID
	@return ApiV2FlexibleAssetIdDeleteRequest
*/
func (a *FlexibleAssetAPIService) V2FlexibleAssetIdDelete(ctx context.Context, id int32) ApiV2FlexibleAssetIdDeleteRequest {
	return ApiV2FlexibleAssetIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *FlexibleAssetAPIService) V2FlexibleAssetIdDeleteExecute(r ApiV2FlexibleAssetIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetAPIService.V2FlexibleAssetIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/flexible-asset/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2FlexibleAssetIdGetRequest struct {
	ctx        context.Context
	ApiService *FlexibleAssetAPIService
	id         int32
}

func (r ApiV2FlexibleAssetIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2FlexibleAssetIdGetExecute(r)
}

/*
V2FlexibleAssetIdGet Get a flexible asset by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Flexible asset ID
	@return ApiV2FlexibleAssetIdGetRequest
*/
func (a *FlexibleAssetAPIService) V2FlexibleAssetIdGet(ctx context.Context, id int32) ApiV2FlexibleAssetIdGetRequest {
	return ApiV2FlexibleAssetIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *FlexibleAssetAPIService) V2FlexibleAssetIdGetExecute(r ApiV2FlexibleAssetIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetAPIService.V2FlexibleAssetIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/flexible-asset/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2FlexibleAssetIdPatchRequest struct {
	ctx        context.Context
	ApiService *FlexibleAssetAPIService
	id         int32
	operation  *[]Operation
}

// The JSON patch operations to apply
func (r ApiV2FlexibleAssetIdPatchRequest) Operation(operation []Operation) ApiV2FlexibleAssetIdPatchRequest {
	r.operation = &operation
	return r
}

func (r ApiV2FlexibleAssetIdPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2FlexibleAssetIdPatchExecute(r)
}

/*
V2FlexibleAssetIdPatch Apply partial updates to an existing flexible asset using JSON Patch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The flexible asset ID
	@return ApiV2FlexibleAssetIdPatchRequest
*/
func (a *FlexibleAssetAPIService) V2FlexibleAssetIdPatch(ctx context.Context, id int32) ApiV2FlexibleAssetIdPatchRequest {
	return ApiV2FlexibleAssetIdPatchRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *FlexibleAssetAPIService) V2FlexibleAssetIdPatchExecute(r ApiV2FlexibleAssetIdPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPatch
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetAPIService.V2FlexibleAssetIdPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/flexible-asset/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.operation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2FlexibleAssetPostRequest struct {
	ctx                        context.Context
	ApiService                 *FlexibleAssetAPIService
	createFlexibleAssetRequest *CreateFlexibleAssetRequest
}

// The flexible asset details
func (r ApiV2FlexibleAssetPostRequest) CreateFlexibleAssetRequest(createFlexibleAssetRequest CreateFlexibleAssetRequest) ApiV2FlexibleAssetPostRequest {
	r.createFlexibleAssetRequest = &createFlexibleAssetRequest
	return r
}

func (r ApiV2FlexibleAssetPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V2FlexibleAssetPostExecute(r)
}

/*
V2FlexibleAssetPost Create a new flexible asset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV2FlexibleAssetPostRequest
*/
func (a *FlexibleAssetAPIService) V2FlexibleAssetPost(ctx context.Context) ApiV2FlexibleAssetPostRequest {
	return ApiV2FlexibleAssetPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FlexibleAssetAPIService) V2FlexibleAssetPostExecute(r ApiV2FlexibleAssetPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetAPIService.V2FlexibleAssetPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/flexible-asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/json-patch+json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFlexibleAssetRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2OdataFlexibleAssetRequest struct {
	ctx        context.Context
	ApiService *FlexibleAssetAPIService
}

func (r ApiV2OdataFlexibleAssetRequest) Execute() ([]FlexibleAsset, *http.Response, error) {
	return r.ApiService.V2OdataFlexibleAssetExecute(r)
}

/*
V2OdataFlexibleAsset Gets flexible assets

Supports OData filtering, sorting, and paging.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV2OdataFlexibleAssetRequest
*/
func (a *FlexibleAssetAPIService) V2OdataFlexibleAsset(ctx context.Context) ApiV2OdataFlexibleAssetRequest {
	return ApiV2OdataFlexibleAssetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []FlexibleAsset
func (a *FlexibleAssetAPIService) V2OdataFlexibleAssetExecute(r ApiV2OdataFlexibleAssetRequest) ([]FlexibleAsset, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FlexibleAsset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetAPIService.V2OdataFlexibleAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/odata/flexibleasset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/octet-stream", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2OdataFlexibleAssetCountRequest struct {
	ctx        context.Context
	ApiService *FlexibleAssetAPIService
}

func (r ApiV2OdataFlexibleAssetCountRequest) Execute() ([]FlexibleAsset, *http.Response, error) {
	return r.ApiService.V2OdataFlexibleAssetCountExecute(r)
}

/*
V2OdataFlexibleAssetCount Gets flexible assets

Supports OData filtering, sorting, and paging.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV2OdataFlexibleAssetCountRequest
*/
func (a *FlexibleAssetAPIService) V2OdataFlexibleAssetCount(ctx context.Context) ApiV2OdataFlexibleAssetCountRequest {
	return ApiV2OdataFlexibleAssetCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []FlexibleAsset
func (a *FlexibleAssetAPIService) V2OdataFlexibleAssetCountExecute(r ApiV2OdataFlexibleAssetCountRequest) ([]FlexibleAsset, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FlexibleAsset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlexibleAssetAPIService.V2OdataFlexibleAssetCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/odata/flexibleasset/$count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;odata.metadata=minimal;odata.streaming=true", "application/json;odata.metadata=minimal;odata.streaming=false", "application/json;odata.metadata=minimal", "application/json;odata.metadata=full;odata.streaming=true", "application/json;odata.metadata=full;odata.streaming=false", "application/json;odata.metadata=full", "application/json;odata.metadata=none;odata.streaming=true", "application/json;odata.metadata=none;odata.streaming=false", "application/json;odata.metadata=none", "application/json;odata.streaming=true", "application/json;odata.streaming=false", "application/json", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=minimal;IEEE754Compatible=false", "application/json;odata.metadata=minimal;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=full;IEEE754Compatible=false", "application/json;odata.metadata=full;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true", "application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=false", "application/json;odata.metadata=none;IEEE754Compatible=true", "application/json;odata.streaming=true;IEEE754Compatible=false", "application/json;odata.streaming=true;IEEE754Compatible=true", "application/json;odata.streaming=false;IEEE754Compatible=false", "application/json;odata.streaming=false;IEEE754Compatible=true", "application/json;IEEE754Compatible=false", "application/json;IEEE754Compatible=true", "application/xml", "text/plain", "application/octet-stream", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
